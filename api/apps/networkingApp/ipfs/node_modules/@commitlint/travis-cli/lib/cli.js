#!/usr/bin/env node
'use strict';

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const execa = require('execa');
const commitlint = require('@commitlint/cli');

// Allow to override used bins for testing purposes
const GIT = process.env.TRAVIS_COMMITLINT_GIT_BIN || 'git';
const COMMITLINT = process.env.TRAVIS_COMMITLINT_BIN;

const REQUIRED = ['TRAVIS_COMMIT', 'TRAVIS_COMMIT_RANGE', 'TRAVIS_EVENT_TYPE', 'TRAVIS_REPO_SLUG', 'TRAVIS_PULL_REQUEST_SLUG'];

const COMMIT = process.env.TRAVIS_COMMIT;
const REPO_SLUG = process.env.TRAVIS_REPO_SLUG;
const PR_SLUG = process.env.TRAVIS_PULL_REQUEST_SLUG || REPO_SLUG;
const RANGE = process.env.TRAVIS_COMMIT_RANGE;
const IS_PR = process.env.TRAVIS_EVENT_TYPE === 'pull_request';

main().catch(err => {
	console.log(err);
	process.exit(1);
});

function main() {
	return new Promise(function ($return, $error) {
		var pop, _RANGE$split$filter, _RANGE$split$filter2, start, end, input;

		validate();

		// Stash changes in working copy if needed
		return Promise.resolve(stash()).then(function ($await_2) {
			try {
				pop = $await_2;
				return Promise.resolve(Promise.all([() => fetch({ name: 'base', url: `https://github.com/${REPO_SLUG}.git` }), IS_PR ? () => fetch({ name: 'source', url: `https://github.com/${PR_SLUG}.git` }) : () => new Promise(function ($return, $error) {
					return $return();
				}.bind(this))])).then(function ($await_3) {
					try {
						return Promise.resolve(pop()).then(function ($await_4) {
							try {

								// Lint all commits in TRAVIS_COMMIT_RANGE if available
								if (IS_PR && RANGE) {
									_RANGE$split$filter = RANGE.split('.').filter(Boolean), _RANGE$split$filter2 = (0, _slicedToArray3.default)(_RANGE$split$filter, 2);
									start = _RANGE$split$filter2[0], end = _RANGE$split$filter2[1];
									return Promise.resolve(lint(['--from', start, '--to', end])).then(function ($await_5) {
										try {
											return $If_1.call(this);
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								} else {
									return Promise.resolve(log(COMMIT)).then(function ($await_6) {
										try {
											input = $await_6;
											return Promise.resolve(lint([], { input })).then(function ($await_7) {
												try {
													return $If_1.call(this);
												} catch ($boundEx) {
													return $error($boundEx);
												}
											}.bind(this), $error);
										} catch ($boundEx) {
											return $error($boundEx);
										}
									}.bind(this), $error);
								}

								function $If_1() {
									return $return();
								}
							} catch ($boundEx) {
								return $error($boundEx);
							}
						}.bind(this), $error);
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
}

function git(args, options) {
	return new Promise(function ($return, $error) {
		return $return(execa(GIT, args, Object.assign({}, { stdio: 'inherit' }, options)));
	}.bind(this));
}

function fetch({ name, url }) {
	return new Promise(function ($return, $error) {
		return Promise.resolve(git(['remote', 'add', name, url])).then(function ($await_8) {
			try {
				return Promise.resolve(git(['fetch', name, '--quiet'])).then(function ($await_9) {
					try {
						return $return();
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
}

function isClean() {
	return new Promise(function ($return, $error) {
		var result;
		return Promise.resolve(git(['status', '--porcelain'], {
			stdio: ['pipe', 'pipe', 'pipe']
		})).then(function ($await_10) {
			try {
				result = $await_10;

				return $return(!(result.stdout && result.stdout.trim()));
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
}

function lint(args, options) {
	return new Promise(function ($return, $error) {
		return $return(execa(COMMITLINT || commitlint, args, Object.assign({}, { stdio: ['pipe', 'inherit', 'inherit'] }, options)));
	}.bind(this));
}

function log(hash) {
	return new Promise(function ($return, $error) {
		var result;
		return Promise.resolve(execa('git', ['log', '-n', '1', '--pretty=format:%B', hash])).then(function ($await_11) {
			try {
				result = $await_11;

				return $return(result.stdout);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
}

function stash() {
	return new Promise(function ($return, $error) {
		return Promise.resolve(isClean()).then(function ($await_12) {
			try {
				if ($await_12) {
					return $return(() => new Promise(function ($return, $error) {
						return $return();
					}.bind(this)));
				}
				return Promise.resolve(git(['stash', '-k', '-u', '--quiet'])).then(function ($await_13) {
					try {
						return $return(() => git(['stash', 'pop', '--quiet']));
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
}

function validate() {
	if (process.env.CI !== 'true' || process.env.TRAVIS !== 'true') {
		throw new Error(`@commitlint/travis-cli is intended to be used on Travis CI`);
	}

	const missing = REQUIRED.filter(envVar => !(envVar in process.env));

	if (missing.length > 0) {
		const stanza = missing.length > 1 ? 'they were not' : 'it was not';
		throw new Error(`Expected ${missing.join(', ')} to be defined globally, ${stanza}.`);
	}
}
//# sourceMappingURL=cli.js.map