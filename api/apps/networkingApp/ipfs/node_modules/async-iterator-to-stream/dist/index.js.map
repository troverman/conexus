{"version":3,"sources":["../src/index.js"],"names":["require","Readable","getSymbol","Symbol","name","symbol","undefined","$$asyncIterator","asyncIteratorToStream","$$iterator","resolveToIterator","value","tmp","call","iterable","options","apply","arguments","then","iterator","isGenerator","readable","_destroy","error","cb","throw","return","running","_read","size","cursor","next","done","push","process","nextTick","emit","bind","module","exports","obj","objectMode"],"mappings":"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","sourcesContent":["const { Readable } = require(\"readable-stream\");\n\nconst getSymbol =\n  typeof Symbol === \"function\"\n    ? name => {\n        const symbol = Symbol[name];\n        return symbol !== undefined ? symbol : `@@${name}`;\n      }\n    : name => `@@${name}`;\n\nconst $$asyncIterator = (asyncIteratorToStream.$$asyncIterator = getSymbol(\n  \"asyncIterator\"\n));\nconst $$iterator = (asyncIteratorToStream.$$iterator = getSymbol(\"iterator\"));\n\nconst resolveToIterator = value => {\n  let tmp;\n  if (typeof (tmp = value[$$asyncIterator]) === \"function\") {\n    return tmp.call(value); // async iterable\n  }\n  if (typeof (tmp = value[$$iterator]) === \"function\") {\n    return tmp.call(value); // iterable\n  }\n  return value; // iterator\n};\n\n// Create a readable stream from a sync/async iterator\n//\n// If a generator is passed instead of an iterator, a factory is returned\n// instead of a plain readable stream.\n//\n// The generator can be async or can yield promises to wait for them.\n//\n// `yield` returns the `size` parameter of the next method, the generator can\n// ask for it without generating a value by yielding `undefined`.\nfunction asyncIteratorToStream(iterable, options) {\n  if (typeof iterable === \"function\") {\n    return function() {\n      return asyncIteratorToStream(iterable.apply(this, arguments), options);\n    };\n  }\n\n  const { then } = iterable;\n  if (typeof then === \"function\") {\n    return then.call(iterable, iterable =>\n      asyncIteratorToStream(iterable, options)\n    );\n  }\n\n  const iterator = resolveToIterator(iterable);\n  const isGenerator = \"return\" in iterator;\n  const readable =\n    options instanceof Readable ? options : new Readable(options);\n  if (isGenerator) {\n    readable._destroy = async (error, cb) => {\n      try {\n        await (error != null ? iterator.throw(error) : iterator.return());\n      } catch (error) {\n        return cb(error);\n      }\n      cb(error);\n    };\n  }\n  let running = false;\n  readable._read = async size => {\n    if (running) {\n      return;\n    }\n    running = true;\n    try {\n      let value;\n      do {\n        let cursor = iterator.next(size);\n\n        // return the next value of the iterator but if it is a promise, resolve it and\n        // reinject it\n        //\n        // this enables the use of a simple generator instead of an async generator\n        // (which are less widely supported)\n        if (typeof cursor.then === \"function\") {\n          cursor = await cursor;\n        } else {\n          while (\n            !cursor.done &&\n            (value = cursor.value) != null &&\n            typeof value.then === \"function\"\n          ) {\n            try {\n              value = await value;\n            } catch (error) {\n              cursor = iterator.throw(error);\n              continue\n            }\n            cursor = iterator.next(value);\n          }\n        }\n\n        if (cursor.done) {\n          return readable.push(null);\n        }\n        value = cursor.value;\n      } while (value === undefined || readable.push(value));\n    } catch (error) {\n      process.nextTick(readable.emit.bind(readable, \"error\", error));\n    } finally {\n      running = false;\n    }\n  };\n  return readable;\n}\nmodule.exports = asyncIteratorToStream;\n\nasyncIteratorToStream.obj = (iterable, options) =>\n  asyncIteratorToStream(iterable, {\n    objectMode: true,\n    ...options,\n  });\n"],"file":"index.js"}