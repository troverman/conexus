{"version":3,"sources":["LatencyMonitor.js"],"names":["debug","require","LatencyMonitor","latencyCheckIntervalMs","dataEmitIntervalMs","asyncTestFn","latencyRandomPercentage","that","_latecyCheckMultiply","_latecyCheckSubtract","undefined","process","hrtime","now","getDeltaMS","startTime","window","performance","bind","Math","round","Date","_latencyData","_initLatencyData","isBrowser","_visibilityChangeEmitter","on","pageInFocus","_startTimers","_emitSummary","_stopTimers","isVisible","_checkLatencyID","_checkLatency","_emitIntervalID","setInterval","unref","clearTimeout","clearInterval","summary","getSummary","events","emit","latency","minMs","maxMs","avgMs","totalMs","Number","POSITIVE_INFINITY","lengthMs","randomness","random","localData","deltaOffset","ceil","cb","deltaMS","min","max","setTimeout","NEGATIVE_INFINITY"],"mappings":"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","file":"LatencyMonitor.js","sourcesContent":["/* global window */\nimport EventEmitter from 'events';\nimport lodashGet from 'lodash/get';\nimport isFunction from 'lodash/isFunction';\nimport VisibilityChangeEmitter from './VisibilityChangeEmitter';\n\nconst debug = require('debug')('latency-monitor:LatencyMonitor');\n\n/**\n * @typedef {Object} SummaryObject\n * @property {Number} events How many events were called\n * @property {Number} minMS What was the min time for a cb to be called\n * @property {Number} maxMS What was the max time for a cb to be called\n * @property {Number} avgMs What was the average time for a cb to be called\n * @property {Number} lengthMs How long this interval was in ms\n */\n\n/**\n * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling\n * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.\n * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.\n *\n * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop\n * and timing how long it takes to get back.\n *\n * @example\n * const monitor = new LatencyMonitor();\n * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));\n *\n * @example\n * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});\n * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));\n */\nclass LatencyMonitor extends EventEmitter {\n    /**\n     * @param {Number} [latencyCheckIntervalMs=500] How often to add a latency check event (ms)\n     * @param {Number} [dataEmitIntervalMs=5000] How often to summarize latency check events. null or 0 disables event firing\n     * @param {function} [asyncTestFn] What cb-style async function to use\n     * @param {Number} [latencyRandomPercentage=5] What percent (+/-) of latencyCheckIntervalMs should we randomly use? This helps avoid alignment to other events.\n     */\n    constructor({latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage} = {}) {\n        super();\n        const that = this;\n\n        // 0 isn't valid here, so its ok to use ||\n        that.latencyCheckIntervalMs = latencyCheckIntervalMs || 500; // 0.5s\n        that.latencyRandomPercentage = latencyRandomPercentage || 10;\n        that._latecyCheckMultiply = 2 * (that.latencyRandomPercentage / 100.0) * that.latencyCheckIntervalMs;\n        that._latecyCheckSubtract = that._latecyCheckMultiply / 2;\n\n        that.dataEmitIntervalMs = (dataEmitIntervalMs === null || dataEmitIntervalMs === 0) ? undefined\n            : dataEmitIntervalMs || 5 * 1000; // 5s\n        debug('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s',\n            that.latencyCheckIntervalMs, that.dataEmitIntervalMs);\n        if (that.dataEmitIntervalMs) {\n            debug('Expecting ~%s events per summary', that.latencyCheckIntervalMs / that.dataEmitIntervalMs);\n        } else {\n            debug('Not emitting summaries');\n        }\n\n        that.asyncTestFn = asyncTestFn; // If there is no asyncFn, we measure latency\n\n        // If process: use high resolution timer\n        if (process && process.hrtime) {\n            debug('Using process.hrtime for timing');\n            that.now = process.hrtime;\n            that.getDeltaMS = (startTime) => {\n                const hrtime = that.now(startTime);\n                return (hrtime[0] * 1000) + (hrtime[1] / 1000000);\n            };\n            // Let's try for a timer that only monotonically increases\n        } else if (typeof window !== 'undefined' && lodashGet(window, 'performance.now')) {\n            debug('Using performance.now for timing');\n            that.now = window.performance.now.bind(window.performance);\n            that.getDeltaMS = (startTime) => Math.round(that.now() - startTime);\n        } else {\n            debug('Using Date.now for timing');\n            that.now = Date.now;\n            that.getDeltaMS = (startTime) => that.now() - startTime;\n        }\n\n        that._latencyData = that._initLatencyData();\n\n        // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,\n        // so we fall back to another library\n        // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs\n        if (isBrowser()) {\n            that._visibilityChangeEmitter = new VisibilityChangeEmitter();\n            that._visibilityChangeEmitter.on('visibilityChange', (pageInFocus) => {\n                if (pageInFocus) {\n                    that._startTimers();\n                } else {\n                    that._emitSummary();\n                    that._stopTimers();\n                }\n            });\n        }\n\n        if (!that._visibilityChangeEmitter || that._visibilityChangeEmitter.isVisible()) {\n            that._startTimers();\n        }\n    }\n\n    /**\n     * Start internal timers\n     * @private\n     */\n    _startTimers() {\n        // Timer already started, ignore this\n        if (this._checkLatencyID) {\n            return;\n        }\n        this._checkLatency();\n        if (this.dataEmitIntervalMs) {\n            this._emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);\n            if (isFunction(this._emitIntervalID.unref)) {\n                this._emitIntervalID.unref(); // Doesn't block exit\n            }\n        }\n    }\n\n    /**\n     * Stop internal timers\n     * @private\n     */\n    _stopTimers() {\n        if (this._checkLatencyID) {\n            clearTimeout(this._checkLatencyID);\n            this._checkLatencyID = undefined;\n        }\n        if (this._emitIntervalID) {\n            clearInterval(this._emitIntervalID);\n            this._emitIntervalID = undefined;\n        }\n    }\n\n    /**\n     * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show\n     * @private\n     */\n    _emitSummary() {\n        const summary = this.getSummary();\n        if (summary.events > 0) {\n            this.emit('data', summary);\n        }\n    }\n\n    /**\n     * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,\n     * it will not count for this time period\n     * @returns {SummaryObject}\n     */\n    getSummary() {\n        // We might want to adjust for the number of expected events\n        // Example: first 1 event it comes back, then such a long blocker that the next emit check comes\n        // Then this fires - looks like no latency!!\n        const latency = {\n            events: this._latencyData.events,\n            minMs: this._latencyData.minMs,\n            maxMs: this._latencyData.maxMs,\n            avgMs: this._latencyData.events ? this._latencyData.totalMs / this._latencyData.events\n                : Number.POSITIVE_INFINITY,\n            lengthMs: this.getDeltaMS(this._latencyData.startTime)\n        };\n        this._latencyData = this._initLatencyData(); // Clear\n\n        debug('Summary: %O', latency);\n        return latency;\n    }\n\n    /**\n     * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,\n     * it will simply report on event loop latency.\n     *\n     * @private\n     */\n    _checkLatency() {\n        const that = this;\n        // Randomness is needed to avoid alignment by accident to regular things in the event loop\n        const randomness = (Math.random() * that._latecyCheckMultiply) - that._latecyCheckSubtract;\n\n\n        // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset\n        const localData = {\n            deltaOffset: Math.ceil(that.latencyCheckIntervalMs + randomness),\n            startTime: that.now()\n        };\n\n        const cb = () => {\n            // We are already stopped, ignore this datapoint\n            if (!this._checkLatencyID) {\n                return;\n            }\n            const deltaMS = that.getDeltaMS(localData.startTime) - localData.deltaOffset;\n            that._checkLatency();  // Start again ASAP\n\n            // Add the data point. If this gets complex, refactor it\n            that._latencyData.events++;\n            that._latencyData.minMs = Math.min(that._latencyData.minMs, deltaMS);\n            that._latencyData.maxMs = Math.max(that._latencyData.maxMs, deltaMS);\n            that._latencyData.totalMs += deltaMS;\n            debug('MS: %s Data: %O', deltaMS, that._latencyData);\n        };\n        debug('localData: %O', localData);\n\n        this._checkLatencyID = setTimeout(() => {\n            // This gets rid of including event loop\n            if (that.asyncTestFn) {\n                // Clear timing related things\n                localData.deltaOffset = 0;\n                localData.startTime = that.now();\n                that.asyncTestFn(cb);\n            } else {\n                // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.\n                // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.\n                localData.deltaOffset -= 1;\n                // If there is no function to test, we mean check latency which is a special case that is really cb => cb()\n                // We avoid that for the few extra function all overheads. Also, we want to keep the timers different\n                cb();\n            }\n        }, localData.deltaOffset);\n\n        if (isFunction(this._checkLatencyID.unref)) {\n            this._checkLatencyID.unref(); // Doesn't block exit\n        }\n    }\n\n    _initLatencyData() {\n        return {\n            startTime: this.now(),\n            minMs: Number.POSITIVE_INFINITY,\n            maxMs: Number.NEGATIVE_INFINITY,\n            events: 0,\n            totalMs: 0\n        };\n    }\n}\n\nfunction isBrowser() {\n    return typeof window !== 'undefined';\n}\n\nexport default LatencyMonitor;\n"]}