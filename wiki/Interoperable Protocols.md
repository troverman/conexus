# Interoperable Protocol Architecture
## Information mapping to a balance
## Tokens are meta data ‘imbued’ as tradable assets

```
contract Protocol {
 
}
```

Work In Progress Token Structure
```javascript
var humanReadableValidationNFTModel = {
	string: 'VALIDATION+'+data[x][y].id,
	information:{
		inCirculation:1,
		markets:0,
	},
	protocols:[
		'BASE',
	],
	logic:{
		transferrable:true, 
		mint:'ONCREATEVALIDATION'
	}
};
```

Protocols define logic and create 'logic manifolds' nested within a token strucutre. 

# Layered Adaptability

# Core protocols
	Rotational Equalities via language interperlation & algebra(s) | a+b+c is congruent (≅) to c+b+a is congruent (≅) to b+c+a)
	//Market Bets.. +FUTURE+[TIME]

## Data Protocol	

## Project Protocol
	The set of logic is driven by the organization
	the manifold defined 'PROJECT+{ID}' 
	PROJECT+{ID} || CUSTOM STRING SPACE IE NOVO; 

## Member Protocol
	MEMBER+{ID} || CUSTOM STRING SPACE IE TROVERMAN; 
	Personal Manifolds

## Content Protocol
	CONTENT
	CONTENT+{ID}

## ORDER Protocol
	ORDER
	ORDER+{ID}

## Reaction Protocol

	Reaction string token domain | all multiplicative combinations of data as tokens

	//DEFINE LOGIC

	//[ACTION] == CREATE, RECEIVE
	//[MODEL] == CONTENT, TIME, ...
	//[TYPE] == LIKE, DISLIKE, ...

	REACTION – Creator and Recipient get 1 REACTION token
	REACTION+{ID} - Creator and Recipient get 1 REACTION+{ID} token

	REACTION+[ACTION] - Creator and Recipient get 1 REACTION+[ACTION] token respectively
	REACTION+[ACTION]+{ID}

	REACTION+[TYPE]
	REACTION+[TYPE]+{ID}

	REACTION+[ACTION]+[TYPE]
	REACTION+[ACTION]+[TYPE]+{ID}

	REACTION+[MODEL]
	REACTION+[MODEL]+[TYPE]

	REACTION+[MODEL]+{ID}
	REACTION+[MODEL]+[TYPE]+{ID}

	REACTION+[ACTION]+[MODEL]
	REACTION+[ACTION]+[MODEL]+[TYPE]

	REACTION+[ACTION]+[MODEL]+{ID}
	REACTION+[ACTION]+[MODEL]+[TYPE]+{ID}

	Linkage with Model (work out rotational equalities via language interperlation & algebra(s) | a+b+c is congruent to c+b+a is congruent to b+c+a)

## Relationship Protocol
	{+[tag]+}
	{+Related Model+}

## Task Protocol
	TASK
	Nested in relationship between Project & Time

## Time Protocol
	TIME
	TIME+{ID}

## Transaction Protocol

	Transaction string token domain | all multiplicative combinations of data as tokens

	TRANSACTION – creator and recipient get 1 TRANSACTION token
	TRANSACTION+creator - creator gets 1 TRANSACTION+creator token
	TRANSACTION+recipient - recipient gets 1 TRANSACTION+recipient token
	 
	//Transaction+descriptionString - recipient gets 1 TRANSACTION+descriptionString token
	 
	TRANSACTION+asset - creator and recipient get 1 TRANSACTION+asset token
	TRANSACTION+asset+creator - creator gets 1 TRANSACTION+asset+creator token
	TRANSACTION+asset+recipient - recipient gets 1 TRANSACTION+asset+recipient token
	 
	TRANSACTION+tag - creator and recipient get 1 TRANSACTION+tag token
	TRANSACTION+tag+creator - creator gets 1 TRANSACTION+tag+creator token
	TRANSACTION+tag+recipient - recipient gets 1 TRANSACTION+tag+recipient token
	 
	TRANSACTION+id – creator and recipient get 1 TRANSACTION+id token
	TRANSACTION+id+creator - creator gets 1 TRANSACTION+id+creator token
	TRANSACTION+id+recipient - recipient gets 1 TRANSACTION+id+recipient token
	 
	TRANSACTION+asset+tag – creator and recipient get 1 TRANSACTION+asset+tag token
	TRANSACTION+asset+tag+creator - creator gets 1 TRANSACTION+asset+tag+creator token
	TRANSACTION+asset+tag+recipient - recipient gets 1 TRANSACTION+asset+tag+ recipient token
	 
	TRANSACTION+asset+id+tag – creator and recipient get 1 TRANSACTION+asset+id+tag token
	TRANSACTION+asset+id+tag+creator - creator gets 1 TRANSACTION+asset+id+tag+creator token
	TRANSACTION+asset+id+tag+recipient - creator gets 1 TRANSACTION+asset+id+tag+recipient token

	TRANSACTION+asset+tag ≅ TRANSACTION+tag+asset ≅ tag+TRANSACTION+asset ≅ tag+asset+TRANSACTION ≅ ....

	TRANSACTION+asset

	USD.SEND VS TRANSACTION+USD+SEND

	VERBS ; CREATOR VS SEND


## View Protocol
	'Address+VIEW+'

## Validation Protocol
	'+VALIDATION'

## Validated Association String Extensions
	PROJECTA+PROJECTB+PROJECTC

# Organizational Pattern
	Project <-> Task <-> Time

# 3rd Layer of Compilation
	Nested Chain Interaction
	Encoding of hashed information into token balance layer begetes emergent value data congruence

```javascript
hash = sha256.getHash("abc"); --> 'ba7816bf­8f01cfea­414140de­5dae2223­b00361a3­96177a9c­b410ff61­f20015ad'
```

## EXAMPLE

	TENANT CLOCKIN TOKEN | BUSHWICK GENERATOR
	bgTime | minted by member on action / KEYIN ~(TIME+ADDRESS)
	usageToken (stu+{context}) | minted by bg ~(BrandedUsageTokenString)
	 
	Liquidity & Sponsorship
	1. Sponsor creates an onMint bgTime liquidity bridge
	      onMint bgTime, receive sponsorship token + bgTime token on action

	2. Sponsor creates a traditional bgTime liquidity bridge
	      Trade bgTime for CRE8; a token; eth; usd | classic
	 
	Reputation comparisons between usageToken and bgTime
	Total usageToken created vs bgTime earned
	  
	Time spent (bgTime) vs Time Credit (usageToken)
	 
	Dimensional onMint usageToken position from bg
		ie perform task (sweep) and receive timeCredit;
	    account for timeCredit and timeSpent
	 
	PURCHASE TIME CREDIT VIA TOKENS
	bg creates trade positionsl sell 1 usageToken @ $0.001388 ($40/8 hours)
	 
	Smart keycard start the clock and checks time space reputation
		Specifically (timeCredit (usageToken)) – (timeSpent(bgTime)) > 0
	    If low  tell em purchase or do chores.
	 
	I need a reputation specific amount of usageToken to key in.

	Life Time reputations with usage + helper task dimensions
